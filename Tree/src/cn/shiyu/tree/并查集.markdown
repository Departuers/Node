###并查集
可以判断网络中节点的状态

网络是个抽象的概念
用户之间形成的网络
比如用户之间的关系网

主要集中数学中的集合类实现

高效的解答连接问题和路径问题

连接问题比路径问题回答的要少
连接只需要求true和false，连没连
不用求出路径

和堆作比较，只关心最大或者最小问题
所以比线性表更快

一些算法经常求出问题所不需要的解，

Union Find
对于一组数据主要支持两个动作
union find(p,q)   并
isConnected(p,q)  判断是否连接
```
第一版
Quick FInd

0   1   2   3   4   5   6   数组下标
0   1   2   3   4   5   6   代表集合编号

0   1   2   3   4   5   6
0   1   0   1   0   1   0    代表奇数一个集合，偶数一个集合 

如果union(1,4),相当于连接了奇数偶数两个集合都在一起了
0   1   2   3   4   5   6
1   1   1   1   1   1   1

Quick Find查询连接    时间复杂度O(1)
Union 合并           时间复杂度元素O(n)
```
第二版
```
将每一个元素，看做是一个节点
开始每一个元素指向它自己
合并思路:p所在集合的根节点指向q所在集合的根节点
判断连接思路:找两个元素的根节点看是否相同

但在顺序合并时，性能会下降成链表，要对树的形状进行判断，不能是个元素就往树上挂上挂
维护一个数组存每颗树的节点数量
```
第三版
```
维护一个数组，存储每一颗树的节点数量
将元素少的树根节点，挂到元素多的节点树根上去
合并时，但在多个节点指向一个根节点，另一个根节点，树的高度更高，
如果数量少的指向数量多的，那么树的高度更高了，
查询效率主要看树的高度，这时候维护一个rank数组，记录树的高度
```
第四版
```
不记录根节点的数量了，记录树的高度
合并时，但在多个节点指向一个根节点，另一个根节点，树的高度更高，
如果数量少的指向数量多的，那么树的高度更高了，
查询效率主要看树的高度，这时候维护一个rank数组，记录树的高度,
```
第五版 最优版本
```
路径压缩把一颗高树，压缩成一个矮的树
parent[p]=parent[parent[p]]

4->3->2->1->0    
```
第六版
```
最理想状态是，压缩成只有2层的树,查询会更快
