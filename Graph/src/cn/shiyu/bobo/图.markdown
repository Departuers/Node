### 图   graph
```
V

图是一种网状数据结构，由非空的顶点集合和一个描述顶点集合关系的集合组成

图由顶点(vertex)和边(edge)组成，顶点表示对象，边表示2个对象间的连接关系

图大体分为两种，边没有指向性的叫无向图，边有指向性的叫有向图。

边可以带权值，叫带权图。比如地图的边权值表示距离，长度一样，但其表示的距离不一样

两个顶点如果有边连接，视为两个顶点相邻

相邻顶点的序列称为路径，
个人理解边有指向的一条路，就是一条路径

起点和终点重合的路径称为圈。

任意两点之间都存在路径连接的图被称为连通图，

顶点连接的所有边数叫做这个顶点的度

树与图

没有圈的连通图就是树， 

没有圈的非连通图就是森林

一条树的边数等于顶点数量-1

边数等于顶点数-1的连通图，就是树。

没有圈的有向图叫DAG，（有向无环图）顺着边的方向走回不去。看起来是有环的,但有方向,回不去

拓扑排序，将DAG中的顶点以线性方式进行排序，对于任何自顶点u到顶点v的有向边，u->v，在最后的排序结果中，顶点u总在顶点v的前面，这样的排序结果，称为拓扑序。

图的分类
        无向          有向
无权    无向无权图     有向无权图
有权    无向有权图     有向有权图

自环边:节点自己指向自己
平行边:某两个节点之间有一条以上的边
遇到图有自环边,或者平行边,要对这张图进行一些处理,大部分情况自环边或者平行边没有意义
没有自环边,没有平行边的称为简单图

图的表示法
1. 邻接矩阵（adjacency matrix）二维数组。
是用来表示图中顶点之间相邻关系的矩阵,表示的是直接连接

空间复杂度O(V^2)  瓶颈!!!节点多了消耗太大资源,稀疏图
时间复杂度
建立图,也就是二维数组,O(E),对两个顶点,赋值为1
查看两个节点是否相邻O(1)
求一个点的相邻节点O(V)   瓶颈!!!

如果一个图有3000个顶点,把顶点两两相连,
                邻接矩阵            邻接表
              3000^2大概1000万,      需要使用5999
求相邻顶点,也就是度数 邻接表degree(v),   邻接矩阵O(v) 
3000个节点,每个节点度数为3,就有3000*3/2=4500条边           因为有重复计算所以要除以二
3000个节点,每个节点度数为2999,最多有3000*2999/2≈450万条边
完全图:每一个顶点都和其他顶点相连,所有的边都有
稠密图不一定是完全图
稠密图:每一个节点和其他节点相连,边比较多
稀疏图:每一个节点和其他节点相连的比较少,边比较少

大部分时候都是稀疏图,
比如北京地图,在中转站度数多点,不过是5,相对整个图的节点数,并不多

无向图的邻接矩阵是一个对称矩阵，有向图不一定；

不带权时使用1/0(1或者0)表示是否有边；带权值时，数值就是权值；
    a   b   c   d       
a   0   10  0   0
b   10  0   5   9
c   0   5   0   3
d   0   9   3   0

当图很稀疏，浪费空间

2. 邻接表（adjacency list）
只关心存在的边，节约空间，使用数组+链表
但是查询两点是否有边需要遍历链表
链表存的是与这个顶点相连的元素

保存权值需要另外存一个边集:就是边的集合Edge Set,保存权值
     value
from------->to
从起点到终点，有权重就是一条边
把一张图所有的边放到一个集，中，扫描边集就能得到一幅图

数组每一个元素都是一个链表，数组的下标表示顶点，
3.边集（adjacency set）
保存权值需要另外存一个边集
     value
from------->to
从起点到终点，有权重就是一条边
把一张图所有的边放到一个集，中，扫描边集就能得到一幅图

3.邻接表(底层存储数据结构变化)
使用HashSet哈希表O(1),或者TreeSet红黑树O(logV)
 * 空间复杂度O(V+E),对于稀疏图而言就是V+2E,对于完全图就是V+(V*(V-1))/2
 * 时间复杂度:建立邻接表O(E*V)使用LinkedList的情况//需要判断平行边
 * 使用HashSet哈希表O(1),//无序
 * 或者TreeSet红黑树O(logV)//保持了节点顺序,相比(哈希表)更节省空间,logV的速度也很快
 * O(1)<O(log n)<O(n)   
 * 如果n取100万,log n=200,如果n取10亿,大概log n是30
 * 1<20<100万

                        空间      建立图时间               查看两点是否相邻                查找点的所有邻边
邻接矩阵               O(V^2)       O(E)                    O(1)                            O(V)
邻接表(LInkedList)     O(V+E)      O(E),如果查重O(E*V)       O(degree(v))最差就是O(V)         O(degree(v))最差就是O(V)
邻接表(TreeSet)        O(V+E)      O(ElogV)查重              O(Log V)                        O(degree(v))最差就是O(V)

遍历的意义:
数据结构是用来存储数据的,把数据存储进去之后,必须有一种方法能遍历数据结构中所存储的数据
在遍历过程中进行查找,匹配之类的工作
很多算法的本质就是遍历,图的遍历很重要
通常不会在图中存储数据,也就是不会在图中做查找,更多的时候存储的是拓扑关系,
通过图论算法来寻找拓扑关系中隐藏的性质,比如节点之间是否相连,或者最短路径,或者最短生成树

图的深度优先遍历(DFS)
对于树,没有环,不用担心重复遍历
对于图,需要记录哪个节点被遍历了,来避免重复遍历,防止有环,再次从其他的路径来到这个顶点

1.求无向图的联通分量(Connected Component)个数
对于无向图:一张图的所有顶点,不一定都是连接起来的,一个互相连接的一部分,就被称为一个联通分量

比如在一个公路系统,每个点表示一个城市,两个节点相连表示两个城市之间有公路联通,
求出联通分量就可以求出在这个地图上有多少独立区域
实现思路:在进行DFS的时候,首先判断当前节点有没有被遍历过,以visited中没有遍历过的节点作为开头进行遍历,下面跟一行count++;
就可以求出有多少联通分量了

2.具体求解无向图的联通分量,
每个联通分量中有多少个节点,每个联通分量的节点分别是哪个
visited还可以是int[]
思路:太精妙看CC2
3.路径问题(单源路径)使用DFS
给出一个源,求这个源,到任意节点有没有路径,
对于无向图:使用联通分量来求,两点在一个联通分量中,意味着两点有路径
使用DFS,在遍历过程中收集pre的信息

4.有时候只求两点有没有路径,不需要求单源到任意一点,就只求两个点
5.检测无向图中的环
使用DFS,寻找有没有一种路径,从一个节点作为起始,能遍历回它自己,
需要注意:从0-1,这时候可以回到0,但0-1不是环,不可以是它前面那一个节点
6.二分图检测(处理匹配问题)使用DFS
二分图定义:顶点V可以分成不相交的两部分,所有的边的端点都隶属于不同的部分
适用于相亲网站左边是男生右边是女生,左边是学生右边是课程
思路:使用DFS进行染色,所谓染色就是赋值
7. 寻找图中的桥
8. 寻找图中的割点
9. 哈密尔顿路径
10. 拓扑排序

图的广度优先遍历(层序遍历)使用队列
树的广度优先遍历和图的差不多,但图需要visited,
树从根节点开始遍历,而图从哪个点开始遍历都可以
思路:先把根节点放进队列,每出来一个节点,
把与该节点相邻的元素都放进队列,入队都在visited记录

1.使用BFS也可以解决无权图的单源最短路径
思路:记录这个节点从哪来的,并查集思想往回找
对于无权图使用BFS求出的路径就是最短路径,还可以顺便求最短距离,
2.所有点对路径问题


最小生成树问题
连通图去掉一条边就是树,
所有生成树中边的权重最小的,称之为最小生成树,常用于网络构建等建设性问题的优化
Kruskal算法,是一种贪心算法
Dijkstra